1. В Go самым эффективным способом конкатенации строк является использование пакета strings и функции Join. Пример:
```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	str := []string{"Hello", "World"}
	result := strings.Join(str, " ")
	fmt.Println(result)
}
```
Вывод:
```
Hello World
```

2. В Go, интерфейсы представляют собой набор методов. Они определяют контракт, который должен быть реализован классами или структурами, чтобы удовлетворять интерфейсу. Интерфейсы в Go используются для достижения полиморфизма. Пример:
```go
package main

import (
	"fmt"
)

type Animal interface {
	Sound() string
}

type Dog struct{}

func (d Dog) Sound() string {
	return "Woof"
}

type Cat struct{}

func (c Cat) Sound() string {
	return "Meow"
}

func MakeSound(a Animal) {
	fmt.Println(a.Sound())
}

func main() {
	dog := Dog{}
	cat := Cat{}

	MakeSound(dog)
	MakeSound(cat)
}
```
Вывод:
```
Woof
Meow
```

3. RWMutex и Mutex - это два разных типа синхронизации в Go. Основное отличие между ними заключается в том, что RWMutex позволяет настроить блокировку для одной или нескольких операций чтения и одной операции записи, тогда как Mutex позволяет настроить блокировку только для одной операции.

4. Буферизированные и не буферизированные каналы отличаются тем, что в буферизированных каналах есть определенный размер буфера, который позволяет отправляющей стороне продолжать отправку данных, даже если принимающая сторона временно не готова принимать. В не буферизированных каналах отправка и получение происходит синхронно, и обе стороны должны быть готовы к операции.

5. Размер структуры struct{}{} в Go равен 0. Конструкция struct{}{} является пустой структурой без полей.

6. В Go отсутствует перегрузка методов и операторов. У каждого метода должно быть уникальное имя, а перегрузка операторов не поддерживается.

7. Элементы map[int]int в Go не имеют определенного порядка. Порядок вывода элементов может быть случайным каждый раз при итерации по map.

8. Разница между make и new в Go заключается в следующем: 
- make используется для создания слайсов, мапов и каналов, а также для инициализации некоторых встроенных типов.
- new используется для выделения памяти под указатель на новый тип и возвращает указатель на нулевое значение этого типа.

Пример:
```go
package main

import (
	"fmt"
)

func main() {
	slice := make([]int, 5) // создание слайса
	fmt.Println(slice)

	ptr := new(int)  // выделение памяти под указатель
	fmt.Println(*ptr)
}
```
Вывод:
```
[0 0 0 0 0]
0
```

9. В Go существует несколько способов задать переменную типа slice или map:
- С помощью литерала:
```go
slice := []int{1, 2, 3}
m := map[string]int{"a": 1, "b": 2}
```
- Используя функции make или new:
```go
slice := make([]int, 0, 5)
m := make(map[string]int)
```
- Инициализация пустого slice или map:
```go
var slice []int
var m map[string]int
```

10. Данная программа выведет:
```
1
1
```
Это происходит потому, что функция `update` принимает указатель на переменную, изменяет указатель на другую память, но не изменяет оригинальную переменную `a` в функции `main`. Поэтому во втором вызове `fmt.Println(*p)` выводится 1, а не 2.

11. Данная программа может выводить числа в произвольном порядке. Это происходит из-за параллельного выполнения горутин, созданных в цикле. Результат может быть разным при каждом запуске программы. В конце будет выведено "exit".

12. Данная программа выведет:
```
0
```
При выполнении `n := 1`, создается новая переменная `n`, локальная для блока if. Инкрементируется локальная переменная, но она остается доступной только внутри блока if. Выводится глобальная переменная `n`, которая не изменилась.

13. Данная программа выведет:
```
[100 2 3 4 5]
```
Передача слайса в функцию осуществляется по значению, поэтому в функции someAction, изменение элемента слайса `v[0]` передается обратно в `a` в функции main. Однако добавление нового элемента с помощью `append` не изменяет оригинальный слайс `a`.

14. Данная программа выведет:
```
[a a]
[a b]
```
Это происходит потому, что передача слайса в функцию осуществляется по значению. При передаче изменяемого значения, такого как слайс, создается копия указателя на базовый массив, но оба слайса ссылаются на один и тот же массив. Поэтому изменения внутри функции влияют на оба слайса.